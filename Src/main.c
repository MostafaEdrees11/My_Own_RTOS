/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Mostafa Edrees
 * @brief          : Lab1 on ARM Modes for Lesson2 on Unit14 (Mastering ARM Cortex-M3/4)
 * @date           : 14/2/2024
 * @board          : STM32F103C8T6
 * @processor      : ARM Cortex M3
 ******************************************************************************
 **/

#include "STM32F103x8.h"
#include "STM32F103x8_GPIO_Driver.h"
#include "STM32F103x8_EXTI_Driver.h"
#include "core_cm3.h"

#include "Scheduler.h"


extern unsigned int _estack;

#define OS_Stack_Size			512
#define TaskA_Stack_Size		100
#define TaskB_Stack_Size		100

/*Bonders of Main Stack Pointer (MSP)*/
unsigned int _S_MSP = (unsigned int)&_estack;
unsigned int _E_MSP;

/*Bonders of Process Stack Pointer of TaskA (PSP_TA)*/
unsigned int _S_PSP_TaskA;
unsigned int _E_PSP_TaskA;


/*Bonders of Process Stack Pointer of TaskB (PSP_TB)*/
unsigned int _S_PSP_TaskB;
unsigned int _E_PSP_TaskB;


uint8_t IRQ_Flag = 0;
uint8_t TaskA_Flag = 0;
uint8_t TaskB_Flag = 0;

#define TaskA		1
#define TaskB		2

#define OS_Generate_Exception_Inerrupt					__asm("SVC #0x3")


//int TaskA_Fun(int a, int b, int c)
//{
//	return a+b+c;
//}
//
//int TaskB_Fun(int a, int b, int c, int d)
//{
//	return a+b+c+d;
//}



//int OS_SVC_Set(int num1, int num2, int SVC_ID)
//{
//	int result;
//
//	switch(SVC_ID)
//	{
//	case 1:	//Addition
//		__asm("SVC #1");
//		break;
//
//	case 2:	//Subtraction
//		__asm("SVC #2");
//		break;
//
//	case 3:	//Multiplication
//		__asm("SVC #3");
//		break;
//	}
//
//	__asm("MOV %[OUT], R0" : [OUT] "=r" (result));
//
//	return result;
//}

//__attribute((naked)) void SVC_Handler(void)
//{
//	// Check which stack we use before stacking MSP or PSP
//	__asm("TST LR, #0x4 \n\t"
//			"ITE EQ \n\t"
//			"MRSEQ R0, MSP \n\t"
//			"MRSNE R0, PSP \n\t"
//			"B OS_SVC_Services");
//}

void TaskA_Fun(void)
{
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, 1);
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, 0);
}

void TaskB_Fun(void)
{
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, 1);
	MCAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, 0);
}

void OS_SVC_Set_First_Task(int SVC_ID)
{
	switch(SVC_ID)
	{
	case 1:	//TaskA
		__asm("SVC #1");
		break;

	case 2:	//TaskB
		__asm("SVC #2");
		break;
	}
}

void PendSV_Handler(void)
{
	if(TaskA_Flag == 1)		//switch to TaskA
	{
		OS_Set_PSP_Val(_S_PSP_TaskA);
		OS_Set_SP_shadowto_PSP;
		TaskA_Fun();
	}
	else if(TaskB_Flag == 1)	//switch to TaskB
	{
		OS_Set_PSP_Val(_S_PSP_TaskB);
		OS_Set_SP_shadowto_PSP;
		TaskB_Fun();
	}
	else
	{

	}
}

void Main_OS(void)
{
	/* OS Stack */
	_E_MSP = (_S_MSP - OS_Stack_Size);

	/* TaskA Stack */
	_S_PSP_TaskA = (_E_MSP - 8);
	_E_PSP_TaskA = (_S_PSP_TaskA - TaskA_Stack_Size);

	/* TaskB Stack */
	_S_PSP_TaskB = (_E_PSP_TaskA - 8);
	_E_PSP_TaskB = (_S_PSP_TaskB - TaskB_Stack_Size);

	OS_SVC_Set_First_Task(TaskA);

	while(1)
	{
		// use SVC to call 1st Task --> TaskA or TaskB
		//		OS_SVC_Set_First_Task(TaskA);

		//		__asm("NOP");
		//
		//		if(TaskA_Flag == 1)
		//		{
		//			/* Set PSP with _S_PSP_TaskA */
		//			OS_Set_PSP_Val(_S_PSP_TaskA);
		//
		//			/* Set SP --> PSP not MSP */
		//			OS_Set_SP_shadowto_PSP;
		//
		//			/* Switch from privileged --> unprivileged*/
		//			OS_Switch_Privileged_to_Unprivileged;
		//
		//			/* Call TaskA */
		//			TaskA_Flag = TaskA_Fun(1, 2, 3);
		//
		//			/* Switch from unprivileged --> privileged*/
		//			OS_Generate_Exception_Inerrupt;
		//
		//			/* Set SP --> MSP not PSP */
		//			OS_Set_SP_shadowto_MSP;
		//		}
		//		else if(TaskB_Flag == 1)
		//		{
		//			/* Set PSP with _S_PSP_TaskB */
		//			OS_Set_PSP_Val(_S_PSP_TaskB);
		//
		//			/* Set SP --> PSP not MSP */
		//			OS_Set_SP_shadowto_PSP;
		//
		//			/* Switch from privileged --> unprivileged*/
		//			OS_Switch_Privileged_to_Unprivileged;
		//
		//			/* Call TaskB */
		//			TaskB_Flag = TaskB_Fun(1, 2, 3, 4);
		//
		//			/* Switch from unprivileged --> privileged*/
		//			OS_Generate_Exception_Inerrupt;
		//
		//			/* Set SP --> MSP not PSP */
		//			OS_Set_SP_shadowto_MSP;
		//		}
		//		else
		//		{
		//
		//		}
	}
}



void EXTI9_CallBack(void)
{
	/* rise the flag of the task that its own order */
	if(IRQ_Flag == 0)
	{
		TaskA_Flag = 1;
		TaskB_Flag = 0;
		IRQ_Flag = 1;
	}
	else if(IRQ_Flag == 1)
	{
		TaskB_Flag = 1;
		TaskA_Flag = 0;
		IRQ_Flag = 0;
	}
	else
	{

	}

	/* set PendSV */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
}

int main(void)
{

	/* Loop forever */
	while(1)
	{
	}
}
